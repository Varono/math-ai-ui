<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#111827" />
  <title>math-ai-ui â€” Ink Canvas</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#111827;
      --panel2:#0f172a;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --border:rgba(148,163,184,.18);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
      --accent:#22c55e;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:radial-gradient(1200px 800px at 20% 10%, rgba(34,197,94,.14), transparent 60%),
                 radial-gradient(1000px 700px at 90% 30%, rgba(59,130,246,.12), transparent 55%),
                 var(--bg);
      color:var(--text);
    }

    .wrap{
      min-height:100%;
      display:flex;
      flex-direction:column;
    }

    header{
      padding:14px 16px;
      display:flex;
      align-items:center;
      gap:12px;
      border-bottom:1px solid var(--border);
      background:rgba(17,24,39,.55);
      backdrop-filter: blur(10px);
      position:sticky;
      top:0;
      z-index:5;
    }
    .brand{
      display:flex;
      flex-direction:column;
      line-height:1.1;
    }
    .brand b{font-size:14px}
    .brand span{font-size:12px;color:var(--muted)}
    .pill{
      margin-left:auto;
      font-size:12px;
      color:var(--muted);
      border:1px solid var(--border);
      padding:6px 10px;
      border-radius:999px;
      background:rgba(15,23,42,.65);
    }

    main{
      flex:1;
      padding:16px;
      max-width:1100px;
      width:100%;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr; }
    }

    .card{
      background:linear-gradient(180deg, rgba(17,24,39,.75), rgba(15,23,42,.75));
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .cardHead{
      padding:12px 12px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .cardHead h2{
      margin:0;
      font-size:13px;
      letter-spacing:.2px;
    }
    .sub{
      margin-left:auto;
      font-size:12px;
      color:var(--muted);
    }

    .inkArea{
      padding:12px;
    }

    /* Canvas container that ALWAYS has size */
    .canvasBox{
      width:100%;
      height:420px;
      border-radius:14px;
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(2,6,23,.55), rgba(2,6,23,.35));
      position:relative;
      overflow:hidden;
    }
    @media (max-width: 980px){
      .canvasBox{height:360px;}
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
      /* critical for stylus + touch */
      touch-action:none;
      cursor:crosshair;
    }

    .tools{
      padding:12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .toolRow{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px;
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(2,6,23,.25);
    }
    .toolRow label{
      font-size:12px;
      color:var(--muted);
      min-width:64px;
    }
    input[type="range"]{
      width:100%;
    }
    input[type="color"]{
      width:42px;height:34px;
      border:none;background:transparent;
      padding:0;cursor:pointer;
    }

    .btnRow{
      grid-column: 1 / -1;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    button{
      border:1px solid var(--border);
      background:rgba(15,23,42,.6);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-size:13px;
      transition: transform .05s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    button:hover{background:rgba(15,23,42,.85); border-color:rgba(148,163,184,.28);}
    button:active{transform:translateY(1px)}
    .primary{
      border-color:rgba(34,197,94,.35);
      background:rgba(34,197,94,.16);
    }
    .primary:hover{
      background:rgba(34,197,94,.22);
      border-color:rgba(34,197,94,.55);
    }
    .danger{
      border-color:rgba(239,68,68,.35);
      background:rgba(239,68,68,.12);
    }
    .danger:hover{
      background:rgba(239,68,68,.18);
      border-color:rgba(239,68,68,.55);
    }

    .side{
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    textarea{
      width:100%;
      min-height:140px;
      resize:vertical;
      border-radius:14px;
      border:1px solid var(--border);
      background:rgba(2,6,23,.25);
      color:var(--text);
      padding:10px 12px;
      outline:none;
      font-size:13px;
      line-height:1.35;
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      padding:0 2px;
    }
    .status{
      font-size:12px;
      color:var(--muted);
      border-top:1px solid var(--border);
      padding:10px 12px;
      background:rgba(2,6,23,.20);
    }
    .dot{
      display:inline-block;
      width:8px;height:8px;border-radius:99px;
      background:var(--accent);
      margin-right:8px;
      box-shadow:0 0 0 3px rgba(34,197,94,.16);
      vertical-align:middle;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <b>math-ai-ui</b>
        <span>Ink Canvas (mouse / touch / stylus) â€” stable</span>
      </div>
      <div class="pill">Static Site ready</div>
    </header>

    <main>
      <!-- Left: Canvas -->
      <section class="card">
        <div class="cardHead">
          <h2>Ink Canvas</h2>
          <div class="sub" id="canvasInfo">â€”</div>
        </div>

        <div class="inkArea">
          <div class="canvasBox" id="canvasBox">
            <canvas id="ink"></canvas>
          </div>
        </div>

        <div class="tools">
          <div class="toolRow">
            <label for="penSize">Î Î¬Ï‡Î¿Ï‚</label>
            <input id="penSize" type="range" min="1" max="28" step="1" value="6" />
            <span id="penSizeVal" style="font-size:12px;color:var(--muted);min-width:24px;text-align:right;">6</span>
          </div>

          <div class="toolRow">
            <label for="penColor">Î§ÏÏÎ¼Î±</label>
            <input id="penColor" type="color" value="#ffffff" />
            <span id="modeLabel" style="font-size:12px;color:var(--muted);margin-left:auto;">Pen</span>
          </div>

          <div class="btnRow">
            <button id="btnPen" class="primary">âœï¸ Pen</button>
            <button id="btnEraser">ğŸ§½ Eraser</button>
            <button id="btnUndo">â†©ï¸ Undo</button>
            <button id="btnClear" class="danger">ğŸ—‘ï¸ Clear</button>
            <button id="btnExport">ğŸ“· Export PNG</button>
          </div>
        </div>

        <div class="status" id="status">
          <span class="dot"></span>
          ÎˆÏ„Î¿Î¹Î¼Î¿. Î“ÏÎ¬ÏˆÎµ ÏƒÏ„Î¿ canvas Î¼Îµ Ï€Î¿Î½Ï„Î¯ÎºÎ¹ / Î´Î¬Ï‡Ï„Ï…Î»Î¿ / stylus.
        </div>
      </section>

      <!-- Right: Notes / Prompt box (optional placeholder for your app) -->
      <aside class="card">
        <div class="cardHead">
          <h2>Î›ÎµÎºÏ„Î¹ÎºÎ® Î±Ï€Î¿ÏÎ¯Î± / ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚</h2>
          <div class="sub">placeholder</div>
        </div>
        <div class="side">
          <div class="hint">
            (Î‘Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Î±Ï€Î»Î¬ â€œÎ´ÎµÎ¾Î¹Î¬ ÏƒÏ„Î®Î»Î·â€ Î³Î¹Î± Î½Î± Î­Ï‡ÎµÎ¹Ï‚ layout. ÎœÏ€Î¿ÏÎµÎ¯Ï‚ Î¼ÎµÏ„Î¬ Î½Î± Î²Î¬Î»ÎµÎ¹Ï‚ ÎµÎ´Ï Ï„Î¿ UI Ï„Î¿Ï… math-ai.)
          </div>
          <textarea id="notes" placeholder="Î“ÏÎ¬ÏˆÎµ ÎµÎ´Ï Ï„Î¿ ÎµÏÏÏ„Î·Î¼Î± Î® Ï„Î¹Ï‚ ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚ ÏƒÎ¿Ï…â€¦"></textarea>
          <div class="hint" id="exportLink"></div>
        </div>
      </aside>
    </main>
  </div>

  <script>
    (() => {
      // --- DOM
      const canvas = document.getElementById('ink');
      const box = document.getElementById('canvasBox');
      const info = document.getElementById('canvasInfo');
      const statusEl = document.getElementById('status');

      const penSize = document.getElementById('penSize');
      const penSizeVal = document.getElementById('penSizeVal');
      const penColor = document.getElementById('penColor');
      const modeLabel = document.getElementById('modeLabel');

      const btnPen = document.getElementById('btnPen');
      const btnEraser = document.getElementById('btnEraser');
      const btnUndo = document.getElementById('btnUndo');
      const btnClear = document.getElementById('btnClear');
      const btnExport = document.getElementById('btnExport');
      const exportLink = document.getElementById('exportLink');

      const ctx = canvas.getContext('2d', { willReadFrequently: false });

      // --- State
      let dpr = Math.max(1, window.devicePixelRatio || 1);
      let drawing = false;
      let last = null; // {x,y,pressure}
      let mode = 'pen'; // 'pen' | 'eraser'
      let currentSize = Number(penSize.value);
      let currentColor = penColor.value;

      // Undo stack (image snapshots)
      const undoStack = [];
      const UNDO_LIMIT = 20;

      // --- Helpers
      function setStatus(msg){
        statusEl.innerHTML = '<span class="dot"></span>' + msg;
      }

      function cssSize(el){
        const r = el.getBoundingClientRect();
        return { w: Math.max(1, Math.floor(r.width)), h: Math.max(1, Math.floor(r.height)) };
      }

      function resizeCanvasToBox(){
        // Ensure the container has a real size
        const { w, h } = cssSize(box);

        dpr = Math.max(1, window.devicePixelRatio || 1);

        // Save current drawing
        const prev = canvas.width > 0 && canvas.height > 0
          ? ctx.getImageData(0, 0, canvas.width, canvas.height)
          : null;

        // Set backing store size
        canvas.width = Math.max(1, Math.floor(w * dpr));
        canvas.height = Math.max(1, Math.floor(h * dpr));

        // Reset transforms then scale so that we draw in CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // Restore
        ctx.clearRect(0, 0, w, h);
        if (prev){
          // drawImage from an ImageData snapshot by putting it back 1:1 in backing store
          // but sizes may change; easiest: putImageData into backing store then let scaling show it.
          // We'll approximate by drawing the old snapshot into a temp canvas, then scale-draw.
          const tmp = document.createElement('canvas');
          tmp.width = prev.width;
          tmp.height = prev.height;
          const tctx = tmp.getContext('2d');
          tctx.putImageData(prev, 0, 0);
          // draw into current canvas in CSS pixels
          ctx.drawImage(tmp, 0, 0, w, h);
        }

        info.textContent = `${w}Ã—${h} (CSS), DPR ${dpr.toFixed(2)}`;
      }

      function getPointFromEvent(e){
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        // pressure: pointer events: 0..1; mouse often 0 or 0.5; make it usable
        let p = (typeof e.pressure === 'number') ? e.pressure : 0.5;
        if (p === 0) p = 0.5;
        // clamp
        p = Math.min(1, Math.max(0.1, p));
        return { x, y, p };
      }

      function pushUndo(){
        try{
          const { w, h } = cssSize(box);
          // store in CSS pixel coordinate snapshot
          const img = ctx.getImageData(0, 0, Math.floor(w * dpr), Math.floor(h * dpr));
          undoStack.push(img);
          if (undoStack.length > UNDO_LIMIT) undoStack.shift();
        }catch(err){
          // ignore if canvas is tainted or memory error
        }
      }

      function applyStrokeStyle(p){
        const size = currentSize;
        const pressureMul = 0.65 + 0.7 * p; // 0.65..1.35-ish
        const width = Math.max(0.8, size * pressureMul);

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = width;

        if (mode === 'eraser'){
          ctx.globalCompositeOperation = 'destination-out';
          ctx.strokeStyle = 'rgba(0,0,0,1)';
        }else{
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = currentColor;
        }
      }

      function drawSegment(a, b){
        applyStrokeStyle(b.p);
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }

      function drawDot(pt){
        applyStrokeStyle(pt.p);
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, ctx.lineWidth / 2, 0, Math.PI * 2);
        ctx.fillStyle = (mode === 'eraser') ? 'rgba(0,0,0,1)' : currentColor;
        if (mode === 'eraser'){
          // eraser dot: destination-out fill
          ctx.globalCompositeOperation = 'destination-out';
          ctx.fill();
          ctx.globalCompositeOperation = 'destination-out';
        }else{
          ctx.globalCompositeOperation = 'source-over';
          ctx.fill();
        }
      }

      // --- Pointer Events (single source of truth: no mouse/touch duplicates)
      function onPointerDown(e){
        // Only primary button for mouse; stylus/touch ok
        if (e.pointerType === 'mouse' && e.button !== 0) return;

        drawing = true;
        exportLink.textContent = '';
        canvas.setPointerCapture(e.pointerId);

        pushUndo();

        const pt = getPointFromEvent(e);
        last = pt;

        // ensure a dot if user taps
        drawDot(pt);

        setStatus('Î“ÏÎ¬Ï†ÎµÎ¹Ï‚â€¦ (Î· Î±Ï€Î¬Î½Ï„Î·ÏƒÎ· Î¸Î± ÎµÎ¼Ï†Î±Î½Î¹ÏƒÏ„ÎµÎ¯ ÎºÎ¬Ï„Ï‰ ÏŒÏ„Î±Î½ Ï„Î·Î½ Î²Î¬Î»ÎµÎ¹Ï‚ ÏƒÏ„Î¿ UI)');
        e.preventDefault();
      }

      function onPointerMove(e){
        if (!drawing) return;
        const pt = getPointFromEvent(e);
        if (last){
          drawSegment(last, pt);
        }
        last = pt;
        e.preventDefault();
      }

      function endStroke(e){
        if (!drawing) return;
        drawing = false;
        last = null;
        try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
        setStatus('Î¤Î­Î»Î¿Ï‚ Î³ÏÎ±Ï†Î®Ï‚ âœ…');
        e.preventDefault();
      }

      // Attach once (no duplicates)
      canvas.addEventListener('pointerdown', onPointerDown, { passive:false });
      canvas.addEventListener('pointermove', onPointerMove, { passive:false });
      canvas.addEventListener('pointerup', endStroke, { passive:false });
      canvas.addEventListener('pointercancel', endStroke, { passive:false });
      canvas.addEventListener('pointerleave', endStroke, { passive:false });

      // Prevent page scrolling while drawing on touch
      canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive:false });
      canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive:false });

      // --- UI bindings
      penSize.addEventListener('input', () => {
        currentSize = Number(penSize.value);
        penSizeVal.textContent = String(currentSize);
      });

      penColor.addEventListener('input', () => {
        currentColor = penColor.value;
      });

      function setMode(next){
        mode = next;
        if (mode === 'pen'){
          btnPen.classList.add('primary');
          btnEraser.classList.remove('primary');
          modeLabel.textContent = 'Pen';
          setStatus('Pen mode âœ…');
        }else{
          btnEraser.classList.add('primary');
          btnPen.classList.remove('primary');
          modeLabel.textContent = 'Eraser';
          setStatus('Eraser mode âœ…');
        }
      }

      btnPen.addEventListener('click', () => setMode('pen'));
      btnEraser.addEventListener('click', () => setMode('eraser'));

      btnClear.addEventListener('click', () => {
        pushUndo();
        const { w, h } = cssSize(box);
        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, w, h);
        ctx.restore();
        setStatus('ÎšÎ±Î¸Î±ÏÎ¯ÏƒÏ„Î·ÎºÎµ âœ…');
      });

      btnUndo.addEventListener('click', () => {
        if (!undoStack.length){
          setStatus('Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î¬Î»Î»Î¿ undo.');
          return;
        }
        const snap = undoStack.pop();
        // Put snapshot back in backing store coords
        const tmp = document.createElement('canvas');
        tmp.width = snap.width;
        tmp.height = snap.height;
        const tctx = tmp.getContext('2d');
        tctx.putImageData(snap, 0, 0);

        const { w, h } = cssSize(box);

        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, w, h);
        ctx.drawImage(tmp, 0, 0, w, h);
        ctx.restore();

        setStatus('Undo âœ…');
      });

      btnExport.addEventListener('click', () => {
        // Export in actual backing store resolution for best quality
        try{
          const dataUrl = canvas.toDataURL('image/png');
          exportLink.innerHTML = `ÎˆÏ„Î¿Î¹Î¼Î¿ PNG: <a href="${dataUrl}" download="ink.png" style="color:#93c5fd;">Download</a>`;
          setStatus('Export PNG âœ…');
        }catch(err){
          exportLink.textContent = 'Export Î±Ï€Î­Ï„Ï…Ï‡Îµ (browser restriction).';
          setStatus('Export Î±Ï€Î­Ï„Ï…Ï‡Îµ.');
        }
      });

      // --- Resize handling: robust against 0x0
      // Use ResizeObserver so it works even when layout changes after load.
      const ro = new ResizeObserver(() => {
        resizeCanvasToBox();
      });
      ro.observe(box);

      // Also do initial sizing after DOM ready & next frame (to avoid 0x0 on first paint)
      function init(){
        resizeCanvasToBox();
        setMode('pen');
        penSizeVal.textContent = String(currentSize);
        setStatus('ÎˆÏ„Î¿Î¹Î¼Î¿ âœ… Î“ÏÎ¬ÏˆÎµ ÏƒÏ„Î¿ canvas (mouse / touch / stylus).');
      }
      if (document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', () => requestAnimationFrame(init), { once:true });
      }else{
        requestAnimationFrame(init);
      }

      // Handle DPR changes (zoom / moving between screens)
      window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`).addEventListener?.('change', () => {
        resizeCanvasToBox();
      });

      // Safety: if tab becomes visible again, re-check size
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) resizeCanvasToBox();
      });
    })();
  </script>
</body>
</html>
